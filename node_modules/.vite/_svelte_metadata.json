{"compilerOptions":{"css":"external","dev":true,"hmr":true},"configFile":false,"extensions":[".svelte",".svx"],"preprocess":[{"name":"mdsvex","markup":"async ({ content, filename }) => {\n\t\t\tlet _layout = {};\n\t\t\tlet layout_mode = 'single';\n\n\t\t\t// if `layout_processed` is undefined, we need to process the layouts\n\t\t\tif (!layouts_processed && !is_browser) {\n\t\t\t\tlet resolve;\n\t\t\t\t// set `layout_processed` before the first await to prevent race conditions\n\t\t\t\tlayouts_processed = new Promise((r) => (resolve = r));\n\t\t\t\tawait handle_path();\n\t\t\t\tif (typeof layout === 'string') {\n\t\t\t\t\t_layout.__mdsvex_default = {\n\t\t\t\t\t\tpath: await resolve_layout(layout),\n\t\t\t\t\t\tcomponents: [],\n\t\t\t\t\t};\n\t\t\t\t} else if (typeof layout === 'object') {\n\t\t\t\t\tlayout_mode = 'named';\n\t\t\t\t\tfor (const name in layout) {\n\t\t\t\t\t\t_layout[name] = {\n\t\t\t\t\t\t\tpath: await resolve_layout(layout[name]),\n\t\t\t\t\t\t\tcomponents: [],\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_layout = await process_layouts(_layout);\n\t\t\t\tparser.add_layouts(_layout, layout_mode);\n\t\t\t\t// resolve the `layout_processed` promise to unlock the rest of the file\n\t\t\t\t// that are waiting before calling parser.process\n\t\t\t\tresolve();\n\t\t\t}\n\n\t\t\tif (highlight && highlight.highlighter === undefined) {\n\t\t\t\thighlight.highlighter = code_highlight;\n\t\t\t}\n\n\t\t\tconst extensionsParts = (extensions || [extension]).map((ext) =>\n\t\t\t\text.startsWith('.') ? ext : '.' + ext\n\t\t\t);\n\t\t\tif (!extensionsParts.some((ext) => filename.endsWith(ext))) return;\n\n\t\t\t// before calling parser.process, we need to wait for the layouts to be processed\n\t\t\t// or else the parser will be frozen\n\t\t\tawait layouts_processed;\n\t\t\tconst parsed = await parser.process({ contents: content, filename });\n\t\t\treturn {\n\t\t\t\tcode: parsed.contents ,\n\t\t\t\tdata: parsed.data ,\n\t\t\t\tmap: '',\n\t\t\t};\n\t\t}"},{"script":"({ content, filename }) => {\n\t\tif (!filename) return;\n\n\t\tconst basename = path.basename(filename);\n\t\tif (basename.startsWith('+page.') || basename.startsWith('+layout.')) {\n\t\t\tconst match = content.match(options_regex);\n\t\t\tif (match && match.index !== undefined && !should_ignore(content, match.index)) {\n\t\t\t\tconst fixed = basename.replace('.svelte', '(.server).js/ts');\n\n\t\t\t\tconst message =\n\t\t\t\t\t`\\n${colors.bold().red(path.relative('.', filename))}\\n` +\n\t\t\t\t\t`\\`${match[1]}\\` will be ignored — move it to ${fixed} instead. See https://svelte.dev/docs/kit/page-options for more information.`;\n\n\t\t\t\tif (!warned.has(message)) {\n\t\t\t\t\tconsole.log(message);\n\t\t\t\t\twarned.add(message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","markup":"({ content, filename }) => {\n\t\tif (!filename) return;\n\n\t\tconst basename = path.basename(filename);\n\t\tconst has_children =\n\t\t\tcontent.includes('<slot') || (isSvelte5Plus() && content.includes('{@render'));\n\n\t\tif (basename.startsWith('+layout.') && !has_children) {\n\t\t\tconst message =\n\t\t\t\t`\\n${colors.bold().red(path.relative('.', filename))}\\n` +\n\t\t\t\t`\\`<slot />\\`${isSvelte5Plus() ? ' or `{@render ...}` tag' : ''}` +\n\t\t\t\t' missing — inner content will not be rendered';\n\n\t\t\tif (!warned.has(message)) {\n\t\t\t\tconsole.log(message);\n\t\t\t\twarned.add(message);\n\t\t\t}\n\t\t}\n\t}"}]}